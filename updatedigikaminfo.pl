#!/usr/bin/perl
################################################################################

=head1 NAME

updatedigikaminfo - updates DigiKam albums and tags based on information
                    extracted from Picasa albums (via extractpicasainfo.pl)

=head1 SYNOPSIS

updatedigikaminfo
   [-?|-h|--help] [-m|--man]
   [-b|--backupdb=</path/to/backup.db>]
   -d|--picasadb=</path/to/picasa.db> | -j|--picasajson=</path/to/picasa.json>
   </path/to/digikam.db>


updatedigikaminfo --help

updatedigikaminfo --picasajson=~/pics/picasa.json --backupdb=~/digikam_backup.db ~/pics/digikam4.db

updatedigikaminfo --picasajson ~/pics/picasa.json ~/pics/digikam4.db

updatedigikaminfo -j ~/pics/picasa.json ~/pics/digikam4.db

updatedigikaminfo --picasadb picasa.db ~/pics/digikam4.db

updatedigikaminfo -d picasa.db -b ~/digikam_backup.db ~/pics/digikam4.db

=head1 OPTIONS

=over 8

=item B<-b, --backupdb=<outfile>>

Creates a backup of the DigiKam database file to the specified outfile
before this program modifies the original.  If the specified outfile exists,
it will not be overwritten; the program will ask you to specify a file that
does not exist.

=item B<-d, --picasadb=<infile>>

Updates the DigiKam database using Picasa album information from the SQLite
database file generated by extractpicasainfo.pl.

=item B<-j, --picasajson=<infile>>

Updates the DigiKam database using Picasa album information from the
JSON-formatted file generated by extractpicasainfo.pl.

=item B<-?, -h, --help>

Displays a brief help message.

=item B<-m, --man>

Displays a detailed help manual.

=back

=head1 DESCRIPTION

This program takes information extracted from Picasa photo albums via
extractpicasainfo.pl and updates the corresponding album and tag information
in the specified DigiKam database.

This program:

   1. Always creates a backup of the specified DigiKam database before
      attempting to modify it.  The backup file is written to the directory
      from which this script is executed unless an explicit backup filename/path
      is provided via the --backupdb option.

      If a backup filename is not explicitly specified, a backup file will be
      created in the current working directory with "~backup_" prefixed with the
      DigiKam database filename.  For example, the default backup file for
      digikam4.db would be ~backup_digikam4.db.

      If the default backup file already exists, it will be overwritten without
      warning.  A custom backup file will never be overwritten; you must
      specify a custom backup file that does not exist.

   2. Only supports importing Picasa data from a JSON-formatted file, not an
      SQLite database file (even though extractpicasainfo.pl outputs
      information in both formats).  SQLite support may be added later if it is
      deemed necessary but is unlikely.

   3. Requires that the DigiKam database be initialized.  That is, you must
      have:
         a. Started the DigiKam program and allowed it to scan the directory
            structure containing Picasa album information.  The DigiKam
            database must be populated with those albums (albeit with missing
            information that we will populate).
         b. Extracted the Picasa album information via extractpicasainfo.pl
            from the same directory structure.
         c. The filenames, directory names, file organization structure
            should be identical for all three events in this sequence:
               i.   When DigiKam initializes its database.
               ii.  When extractpicasainfo.pl extracts the Picasa information.
               iii. When this program updates the DigiKam database with
                    information extracted by extractpicasainfo.pl

To view the SQLite database files used or modified by this program, refer to
the "DB Browser for SQLite" application available at https://sqlitebrowser.org.

=head1 REVISION HISTORY

Alazhar Shamshuddin   2019-06-03   Version 1.0

=head1 COPYRIGHT

(c) Copyright Alazhar Shamshuddin, 2019, All Rights Reserved.

=cut

################################################################################

use strict;
use warnings;

use feature 'fc';                # For case folding comparisons.

use Data::Dumper;                # For debugging data structures.
use DBI qw(:sql_types);          # For updating the DigiKam SQLite database.
use File::Copy;                  # For copying files.
use File::Slurp qw(read_file);   # For reading JSON from a file.
use File::Spec;                  # For managing file paths.
use Getopt::Long;                # For command-line options processing.
use JSON;                        # For reading JSON files.
use Log::Log4perl;               # For logging.
use Pod::Usage;                  # For printing usage clause and man page.

################################################################################
# Global Variables
################################################################################
use constant TRUE  => 1;
use constant FALSE => 0;

my $gLogger        = undef;            # For logging.
my %gCmds          = ();               # For storing command-line options.
my $gJson          = JSON->new->utf8;  # For reading JSON files.

# All DigiKam face tags are created under this ID by DigiKam.  We look it up
# once and save it for future reference for increased efficiency.
my $gPeopleTagId   = undef;

################################################################################
# Subroutines
#
#    All subroutines are organized alphanumerically in the following
#    categories:
#
#       - Main
#            - main
#       - Initialization
#            - initLogger
#            - processCmdLineArgs
#       - DigiKam Database Updates
#            - createDigiKamTag
#            - getDigiKamAlbumId
#            - getDigiKamImageId
#            - getDigiKamTagId
#            - openDbConnection
#            - tagDigikamImage
#            - tagDigikamImageWithFace
#            - updateDigiKam
################################################################################

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main();
sub main
{
   initLogger(0, \$gLogger);
   $gLogger->info("*** Executing $0. ***");

   processCmdLineArgs(\%gCmds);

   copy($gCmds{digikamdb}, $gCmds{backupdb}) or
      $gLogger->logdie("Could not backup '$gCmds{digikamdb}' to " .
                       "'$gCmds{backupdb}': $!");

   my $picasaInfo_hr = read_file($gCmds{picasajson});
   $picasaInfo_hr = $gJson->decode($picasaInfo_hr);

   my $digiKamDbh = openDbConnection($gCmds{digikamdb});
   $gPeopleTagId = getDigiKamTagId($digiKamDbh, 'People');
   updateDigiKam($picasaInfo_hr, $digiKamDbh);

   $digiKamDbh->commit();
   $digiKamDbh->disconnect();

   $gLogger->info("*** Completed executing $0. ***");
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Initialization Subroutines
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#-------------------------------------------------------------------------------
# Initializes the logging functionality.
#
# \param $_[0] [in]  The log configuration filename.
# \param $_[1] [out] A reference to a logger.
#
# \return None.
#-------------------------------------------------------------------------------
sub initLogger
{
   # Initialize the logger.
   my $logConfigFile = $_[0];
   my $logger_sr     = $_[1];

   if (-r $logConfigFile)
   {
      Log::Log4perl->init($logConfigFile);
   }
   else
   {
      # Configuration in a string.
      my $logConfigString = q(
         log4perl.rootLogger=TRACE, FILE, SCREEN

         # Filter to match WARN messages
         #log4perl.filter.MatchInfo = Log::Log4perl::Filter::LevelMatch
         #log4perl.filter.MatchInfo.LevelToMatch = WARN
         #log4perl.filter.MatchInfo.AcceptOnMatch = true

         # Filter to match range from WARN up
         log4perl.filter.MatchWarnUp = Log::Log4perl::Filter::LevelRange
         log4perl.filter.MatchWarnUp.LevelMin = WARN
         #log4perl.filter.MatchWarnUp.LevelMax = FATAL
         log4perl.filter.MatchWarnUp.AcceptOnMatch = true

         #----------------------------------------------------------------------
         # For writing log messages to a file in the following format:
         #
         #   (%r)  (%p)  (%l)                     (%m%n)
         #   [127] ERROR main::fnc file.pl (599): Message.
         #----------------------------------------------------------------------
         log4perl.appender.FILE          = Log::Log4perl::Appender::File
         log4perl.appender.FILE.filename = ./updatedigikaminfo.log
         log4perl.appender.FILE.mode     = clobber
         log4perl.appender.FILE.layout   = PatternLayout
         log4perl.appender.FILE.layout.ConversionPattern = %p %l: %m%n

         #----------------------------------------------------------------------
         # For writing log messages to the screen in the following format:
         #
         #   (%r)  (%p)  (%l)                     (%m%n)
         #   [127] ERROR main::fnc file.pl (599): Message.
         #----------------------------------------------------------------------
         log4perl.appender.SCREEN        = Log::Log4perl::Appender::Screen
         log4perl.appender.SCREEN.stderr = 0
         log4perl.appender.SCREEN.layout = PatternLayout
         log4perl.appender.SCREEN.layout.ConversionPattern = %p %l: %m%n
         log4perl.appender.SCREEN.Filter = MatchWarnUp
         );

      Log::Log4perl::init(\$logConfigString);
   }

   $$logger_sr = Log::Log4perl->get_logger("$0");
   die "FATAL: Could not initialize the logger." unless $$logger_sr;
}

#-------------------------------------------------------------------------------
# Processes command line arguments, and informs the user of invalid
# parameters.  All command line options/values are inserted into the global
# commands hash (gCmds).
#
# This subroutine also displays the usage clause if there are any errors,
# or the help or manual pages if the user explicitly requests them.
# Displaying the usage clause, help page, and manual pages via pod2usage
# automatically terminates this script.
#
# \return None.
#-------------------------------------------------------------------------------
sub processCmdLineArgs
{
   Pod::Usage::pod2usage(1) unless
      Getopt::Long::GetOptions(
        "backupdb|b=s"   => \$gCmds{backupdb},
        "picasadb|d=s"   => \$gCmds{picasadb},
        "picasajson|j=s" => \$gCmds{picasajson},
        "help|h|?"       => \$gCmds{help},
        "man|m"          => \$gCmds{man}
      );

   # We expect no remaining commands/options on the command line after we
   # retrieve the filename and path to the DigiKam SQLite database file.
   # @ARGV should be empty after the following line.
   $gCmds{digikamdb} = shift(@ARGV);

   Pod::Usage::pod2usage(1) if $gCmds{help};
   Pod::Usage::pod2usage(-verbose => 2) if $gCmds{man};

   # Ensure a DigiKam database file is specified.
   if (!defined($gCmds{digikamdb}))
   {
      my $msg = "A Digikam SQLite database file must be specified.";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   # Ensure the DigiKam SQLite database file exists.
   if (defined($gCmds{digikamdb}) && !-e $gCmds{digikamdb})
   {
      my $msg = "The DigiKam SQLite database file '$gCmds{digikamdb}' " .
                "does not exists.";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   # Ensure the input file is not an SQLite database file as we do not yet
   # support it.
   if (defined($gCmds{picasadb}))
   {
      my $msg = "Sorry; we do not yet support processing Picasa information " .
                "from an SQLite database.  Please use a JSON-formatted file ".
                "instead (--picasajson).";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   # Ensure the input JSON file is defined.
   if (!defined($gCmds{picasajson}))
   {
      my $msg = "An input JSON file containing Picasa information " .
                "is required (use --picasajson).";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   # Ensure the JSON input file exists.
   if (defined($gCmds{picasajson}) && !-e $gCmds{picasajson})
   {
      my $msg = "The Picasa JSON-formatted input file '$gCmds{picasajson}' " .
                "does not exist.";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   # Format the specified files to include absolute path information.
   $gCmds{picasajson} = File::Spec->canonpath($gCmds{picasajson});
   $gCmds{picasajson} = File::Spec->rel2abs($gCmds{picasajson});
   $gCmds{digikamdb} = File::Spec->canonpath($gCmds{digikamdb});
   $gCmds{digikamdb} = File::Spec->rel2abs($gCmds{digikamdb});

   # Ensure the Picasa input file and the DigiKam SQLite database file are not
   # the same.
   if (fc($gCmds{picasajson}) eq fc($gCmds{digikamdb}))
   {
      my $msg = "The JSON-formatted Picasa input file '$gCmds{picasajson}' " .
                "cannot be the same as the DigiKam SQLite database output " .
                "file '$gCmds{digikamdb}'.";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }

   if (defined($gCmds{backupdb}))
   {
      if (-e $gCmds{backupdb})
      {
         # Ensure the backup file does not exist.
         my $msg = "The specified backup database file '$gCmds{backupdb}' " .
                   "already exists; please choose one that does not.";

         $gLogger->info($msg);
         print(STDERR "$msg\n\n");
         Pod::Usage::pod2usage(1);
      }
      else
      {
         # Format the specified files to include absolute path information.
         $gCmds{backupdb} = File::Spec->canonpath($gCmds{backupdb});
         $gCmds{backupdb} = File::Spec->rel2abs($gCmds{backupdb});
      }
   }
   else
   {
      # Set the default backup file if one was not specified.  We don't care if
      # this file exists; we will overwrite it without warning.
      my ($srcVolume, $srcDir, $srcFile) =
         File::Spec->splitpath($gCmds{digikamdb});

      $gCmds{backupdb} = File::Spec->catfile(File::Spec->curdir(),
                                             "~backup_$srcFile");
      $gCmds{backupdb} = File::Spec->canonpath($gCmds{backupdb});
      $gCmds{backupdb} = File::Spec->rel2abs($gCmds{backupdb});
   }

   # Ensure there are no more command line parameters to process.
   if (scalar(@ARGV) > 0)
   {
      my $params = join(',', @ARGV);
      my $msg = "Invalid command line entries: '$params'.";

      $gLogger->info($msg);
      print(STDERR "$msg\n\n");
      Pod::Usage::pod2usage(1);
   }
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DigiKam Database Updates
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#-------------------------------------------------------------------------------
# Adds a DigiKam tag property for the specified tag if one does not already
# exist.  If the tag property already exists, we do nothing.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] The ID of the DigiKam tag to which we are adding a property.
# \param $_[2] [in] The property's name or title.
# \param $_[3] [in] The property's value.
#
# \return None.
#-------------------------------------------------------------------------------
sub addTagProperty
{
   my $dbh      = $_[0];
   my $tagId    = $_[1];
   my $property = $_[2];
   my $value    = $_[3];

   my @records =
      $dbh->selectall_array('SELECT *
                             FROM   TagProperties
                             WHERE  tagid = ?
                             AND    property = ?
                             AND    value = ?',
                            undef,
                            $tagId, $property, $value);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $dbh->do('INSERT INTO TagProperties (tagid, property, value)
                            VALUES (?, ?, ?)',
               undef,
               $tagId, $property, $value);
   }
   else
   {
      $gLogger->info("A tag property of '$property' already exists for tag " .
                     "ID '$tagId' with a value of '$value'.");
   }
}

#-------------------------------------------------------------------------------
# Creates a new DigiKam tag under the specified parent tag if one does not
# already exist.  If the tag already exists, we just return its tag ID.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] The name of the tag we want to create.
# \param $_[2] [in] The parent tag's DigiKam ID.
#
# \return The DigiKam tag ID for the tag we just created (or found if it
#         already exists).
#-------------------------------------------------------------------------------
sub createDigiKamTag
{
   my $dbh         = $_[0];
   my $tagName     = $_[1];
   my $parentTagId = $_[2];

   my $tagId   = undef;

   my @records =
      $dbh->selectall_array('SELECT id
                             FROM   Tags
                             WHERE  name = ?
                             AND    pid = ?',
                            undef,
                            $tagName, $parentTagId);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $dbh->do('INSERT INTO Tags (name, pid) VALUES (?, ?)',
               undef,
               $tagName, $parentTagId);

      $tagId = $dbh->last_insert_id();
   }
   else
   {
      $gLogger->info("A tag called '$tagName' already exists with ID '" .
                     $records[0][0] . "' and parent tag ID '$parentTagId'.");

      $tagId = $records[0][0];
   }

   return $tagId;
}

#-------------------------------------------------------------------------------
# Get the DigiKam album ID for an album with the specified name.
#
# @todo: Note DigiKam stores album names as relative paths.  This method simply
# looks for records whose relative paths end with the specified name.  This
# is problematic when more than one album (in different folders) share the
# same name.  For example,
#
#    2023/2023_05_31 - Doing Something Fun
#    Tmp/2023_05_31 - Doing Something Fun
#
# We exclude deleted albums in DigiKam which have an albumRoot of 0 to reduce
# (but not eliminate) the issue of finding multiple album IDs with the same
# name.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] An album name.
#
# \return The DigiKam album ID for an album with the specified name.
#-------------------------------------------------------------------------------
sub getDigiKamAlbumId
{
   my $dbh       = $_[0];
   my $albumName = $_[1];

   my $sth = $dbh->prepare('SELECT id
                            FROM   Albums
                            WHERE  relativePath LIKE ?
                            AND    albumRoot <> 0');
   $sth->bind_param(1, '%' . $albumName);
   $sth->execute();
   my @records = @{$sth->fetchall_arrayref()};

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $gLogger->logdie("Could not find a DigiKam album with name " .
                       "'$albumName'.  Got $numRecords records back " .
                       "instead of 1.");
   }

   return $records[0][0];
}

#-------------------------------------------------------------------------------
# Gets the DigiKam image (file) ID for a file in the specified DigiKam album.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] A DigiKam album ID.
# \param $_[1] [in] A base filename (excluding path information) of an image
#                   in the specified album.
#
# \return The ID of the image in the specified album.
#-------------------------------------------------------------------------------
sub getDigiKamImageId
{
   my $dbh           = $_[0];
   my $albumId       = $_[1];
   my $imageFilename = $_[2];

   my @records =
      $dbh->selectall_array('SELECT id
                             FROM   Images
                             WHERE  album = ?
                             AND    name  = ?',
                            undef,
                            $albumId, $imageFilename);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $gLogger->logdie("Could not find a DigiKam image with filename " .
                       "'$imageFilename' in album '$albumId'.  Got " .
                       "$numRecords back instead of 1.");
   }

   return $records[0][0];
}

#-------------------------------------------------------------------------------
# Gets the DigiKam tag ID of a tag with the specified name.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] A tag name.
#
# \return The DigiKam tag ID associated with the specified name.
#-------------------------------------------------------------------------------
sub getDigiKamTagId
{
   my $dbh     = $_[0];
   my $tagName = $_[1];

   my @records =
      $dbh->selectall_array('SELECT id
                             FROM   Tags
                             WHERE  name = ?',
                            undef,
                            $tagName);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $gLogger->logdie("Could not find a DigiKam tag with name " .
                       "'$tagName'.  Got $numRecords back instead of 1.");
   }

   return $records[0][0];
}

#-------------------------------------------------------------------------------
# Opens a connection to the specified SQLite database.
#
# \param $_[0] [in] The absolute path the specified SQLite database file.
#
# \return A handle the specified SQLite database.
#-------------------------------------------------------------------------------
sub openDbConnection
{
   my $database = $_[0];

   my $driver   = "SQLite";
   my $dsn      = "DBI:$driver:dbname=$database";
   my $userid   = "";
   my $password = "";
   my $dbh      = DBI->connect($dsn,
                               $userid,
                               $password,
                               { RaiseError => 1, AutoCommit => 0 })
      or $gLogger->logdie("Could not create the database: $DBI::errstr.");

   return $dbh;
}

#-------------------------------------------------------------------------------
# Tags the specified image with the specified text, under the specified parent
# tag.
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] The DigiKam image ID of the image we want to tag.
# \param $_[2] [in] The text we want to tag the image with.
# \param $_[3] [in] The DigiKam tag ID of the parent tag under which specified
#                   tag must live.
#
# \return The DigiKam tag ID.
#-------------------------------------------------------------------------------
sub tagDigikamImage
{
   my $dbh         = $_[0];
   my $imageId     = $_[1];
   my $tag         = $_[2];
   my $parentTagId = $_[3];

   my $tagId   = createDigiKamTag($dbh, $tag, $parentTagId);

   my @records =
      $dbh->selectall_array('SELECT *
                             FROM   ImageTags
                             WHERE  imageid = ?
                             AND    tagid = ?',
                            undef,
                            $imageId, $tagId);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $dbh->do('INSERT INTO ImageTags (imageid, tagid) VALUES (?, ?)',
               undef,
               $imageId, $tagId);
   }
   else
   {
      $gLogger->info("Image ID '$imageId' is already tagged with '$tag' (ID " .
                     "'$tagId').")
   }

   return $tagId;
}

#-------------------------------------------------------------------------------
# Tags the specified image with a face tag.
#
# The face tag image coordinates must be specified as per the example below:
#
# @todo: Define where 0,0 is on the rectangle.  Update extractpicasainfo with
#        this note as well
#
#    {
#       'xCoord' => 496,
#       'yCoord' => 202,
#       'width' => 380,
#       'height' => 457
#    }
#
# \param $_[0] [in] A handle to the DigiKam database.
# \param $_[1] [in] The DigiKam image ID of the image we want to tag.
# \param $_[2] [in] The name of the person we want to tag the image with.
# \param $_[3] [in] The hash reference containing the image coordinates of the
#                   rectangular face tag as described above.
#
# \return The DigiKam tag ID associate with the person/face.
#-------------------------------------------------------------------------------
sub tagDigikamImageWithFace
{
   my $dbh              = $_[0];
   my $imageId          = $_[1];
   my $person           = $_[2];
   my $faceTagCoords_hr = $_[3];

   my $tagId = tagDigikamImage($dbh, $imageId, $person, $gPeopleTagId);

   addTagProperty($dbh, $tagId, 'person', $person);
   addTagProperty($dbh, $tagId, 'faceEngineId', $person);

   my $tagRegion = sprintf(qq(<rect x="%u" y="%u" width="%u" height="%u"/>),
                           $faceTagCoords_hr->{xCoord},
                           $faceTagCoords_hr->{yCoord},
                           $faceTagCoords_hr->{width},
                           $faceTagCoords_hr->{height});

   my @records =
      $dbh->selectall_array('SELECT *
                             FROM   ImageTagProperties
                             WHERE  imageid = ?
                             AND    tagid = ?
                             AND    property = ?
                             AND    value = ?',
                            undef,
                            $imageId, $tagId, 'tagRegion', $tagRegion);

   my $numRecords = scalar(@records);

   if ($numRecords != 1 || !defined($records[0]) || !defined($records[0][0]))
   {
      $dbh->do('INSERT INTO   ImageTagProperties
                              (imageid, tagid, property, value)
                       VALUES (?, ?, ?, ?)',
               undef,
               $imageId, $tagId, 'tagRegion', $tagRegion);
   }
   else
   {
      $gLogger->info(
         sprintf("Image ID '%u' is already tagged with person '%s' ".
                 "(tag ID '%u') in the tag region '%s'.",
                 $imageId, $person, $tagId, $tagRegion));
   }

   return $tagId;
}

#-------------------------------------------------------------------------------
# Updates the DigiKam database with information extracted from the Picasa
# JSON file.
#
# \param $_[0] [in] A reference to the Picasa data.
# \param $_[1] [in] A handle to the DigiKam database.
#
# \return None.
#-------------------------------------------------------------------------------
sub updateDigiKam
{
   my $picasaInfo_hr = $_[0];
   my $digiKamDbh    = $_[1];

   my $dAlbums_sth = $digiKamDbh->prepare("UPDATE  Albums
                                           SET     date = ?
                                                  ,caption = REPLACE(?, '\\n', CHAR(10))
                                           WHERE   id = ?");

   my $pAlbums_hr = $picasaInfo_hr->{albums};

   foreach my $pAlbumKey (sort{$a <=> $b} keys(%{$pAlbums_hr}))
   {
      if (!exists($pAlbums_hr->{$pAlbumKey}->{name}))
      {
         $gLogger->error("Picasa album with key '$pAlbumKey' is missing " .
                         "an album name.");
         next;
      }

      if (!exists($pAlbums_hr->{$pAlbumKey}->{directory}))
      {
         $gLogger->error("Picasa album with key '$pAlbumKey' is missing " .
                         "the directory.");
         next;
      }

      my $relativePath = $pAlbums_hr->{$pAlbumKey}->{directory};
      $relativePath =~ s/\/home\/alazhar\/pics//;
      $relativePath =~ s/\/$//;

      # my $dAlbumId =
      #    getDigiKamAlbumId($digiKamDbh, $pAlbums_hr->{$pAlbumKey}->{name});

      my $dAlbumId = getDigiKamAlbumId($digiKamDbh, $relativePath);

      print "$pAlbumKey | $dAlbumId | $relativePath " . $pAlbums_hr->{$pAlbumKey}->{name} . "\n";

      # Update DigiKam album info.
      my $rv = $dAlbums_sth->execute($pAlbums_hr->{$pAlbumKey}->{date},
                                     $pAlbums_hr->{$pAlbumKey}->{description},
                                     $dAlbumId);

      if ($rv != 1)
      {
         $gLogger->error("Could update DigiKam album with id '$dAlbumId' or  " .
                         "name '$pAlbums_hr->{$pAlbumKey}->{name}'.");
      }

      foreach my $image (sort(keys(%{$pAlbums_hr->{$pAlbumKey}->{files}})))
      {
         my $dImageId =
            getDigiKamImageId($digiKamDbh, $dAlbumId, $image);

         print "\t$image $dImageId\n";

         foreach my $imageAttribute (sort(keys(%{$pAlbums_hr->{$pAlbumKey}->{files}->{$image}})))
         {
            print "\t\t$imageAttribute\n";

            if ($imageAttribute eq 'tags')
            {
               foreach my $tag (sort(keys(%{$pAlbums_hr->{$pAlbumKey}->{files}->{$image}->{tags}})))
               {
                  my $dParentTagId = 0;
                  tagDigikamImage($digiKamDbh, $dImageId, $tag, $dParentTagId);
               }
            }
            elsif ($imageAttribute eq 'facetags')
            {
               foreach my $person (sort(keys(%{$pAlbums_hr->{$pAlbumKey}->{files}->{$image}->{facetags}})))
               {
                  my $faceTagCoords_hr = $pAlbums_hr->{$pAlbumKey}->{files}->{$image}->{facetags}->{$person};
                  tagDigikamImageWithFace($digiKamDbh, $dImageId, $person, $faceTagCoords_hr);

               }
            }
            else
            {
               $gLogger->logdie("Unrecognized attribute '$imageAttribute' " .
                                "on image '$image' for album " .
                                "'$pAlbums_hr->{$pAlbumKey}->{name}'.");
            }
         }
      }
   }
}
